package com.hlliu3.algorithm.sort;

/**
 * 二分查找（前提是一定数有序的数组），log 2 N (log以2为底的N) 每次/2，对/2后的数组进行常数时间的判断
 *1 >=num最左侧的位置 或者 <=num最右侧的位置 可以二分
 *2 找某个值存在不存在 可以二分
 *3 局部最小值问题 无序，并且相邻数一定不相等 找局部最小
 *          0位置的数小于1位置的数 0 位置就是局部最小的位置
 *          N-2 N-1 N-1比N-2位置的小，就是局部最小
 *          i-1 i i+1 i最小，就是局部最小
 *          以上3个条件都满足，并且找一个局部最小就可以，时间复杂度小于logOn
 *
 *          0到N-1位置上一定有局部最小
 */

/**
 * 对数器
 * 测试一个好的的程序（优化后的），例如：工具类写好的排序器
 * 随机样本产生器（次数，范围，Math.random()）
 * 一个方便求解，但是程序不好的程序 (自己写的程序)
 * 用随机样本跑两个程序，进行结果比对（结果比对）
 */
public class Code05_BianrySearch {

}
